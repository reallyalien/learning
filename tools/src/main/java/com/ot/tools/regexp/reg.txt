正则表达式语法
java匹配是贪婪匹配，尽可能匹配多的
1.元字符 \\ 我们在使用正则表达式去检索字符串的时候，需要用到转义符号，否则检索不到结果，案例
    用$去匹配“abc$(”会怎么样，用（去匹配又怎么样,
    java当中的\\相当于其他语言的一个\
    需要用到转义的符号：. * + ( ) $  \ ? [] ^ {} ,其实就是正则表达式当中的语法
2.字符匹配符
    [efhg]   表示接收的字符列表->表示匹配efgh的任意一个
    [^efgh]  表示不接受字符列表->表示不匹配efgh的所有，除这几个以外
    - 连字符 A-Z 表示任意单个大写字符
    .        匹配除\n以外的任何一个字符,a..b，以a开头，以b结尾的包括2个任意字符的长度为4的字符串，比如aaab,alkb,a.,b;
    \\d      匹配单个数字字符，相当于[0-9] 实例：\\d{3}(\\d)? 包含3个或4个数字的字符串
    \\D      匹配单个非数字字符，相当于[^0-9]，
    \\w      匹配单个数字，大小写字母字符,下划线，相当于[0-9a-zA-Z_] \\d{3}\\w{4} 匹配3个数字开头的长度为7的数字或字母字符串
    \\W      对上面取反， \\W+\\d{2} 匹配1个或多个不是数字和字母开头的，2个数字字符结尾的字符串 *23
    \\s      匹配任意的空白字符（空格，制表符）
    \\S      上面取反
    java的正则表达式是默认区分大小写的
    (?i)abc 表示abc都不区分大小写
    a(?i)bc 表示bc不区分大小写
    a((?i)b)表示只有b不区分大小写
3.选择匹配符
    在匹配某个字符串的时候，可能是选择性的，即既可以匹配这个，也可以匹配那个，这时需要用到选择匹配符
    | 相当于java当中的或
4.限定符
   用于指定前面的字符和组合连续出现多少次
   *    0到多 (abc)*,仅包含任意个abc的字符串
   +    1到多 ,m+(abc)* 至少一个m开头，后面接abc的字符串
   ？   0或1次,m+abc? ,以至少一个m开头，然后接ab或abc的字符串
   {n}  只能输出n个字符 [abcd]{3}由abcd组成的任意3个长度的字符串
   {n，}  至少输出n个字符 [abcd]{3}由abcd组成的任意不小于3个长度的字符串
   {n，m}  至少n，最多m
4.定位符
 规定要匹配的字符串出现的位置，
  ^    指定起始字符   ^[0-9]+[a-z]* 以至少一个数字开头，后面接任意个小写字母
  $    指定结束符     ^[0-9]\\-[a-z]+$
  \\b  匹配目标字符串的边界 han\\b 这里说的边界是指子串之间有空格，或者是目标字符串的结束位置
  \\B  上面取反，非边界
5. ()分组
（）非命名捕获，捕获匹配的子字符串，编号为0的第一个捕获是由整个正则表达式匹配的文本，其他捕获结果根据括号的顺序从1开始编号
（？<name>）命名捕获，给分组起了个名字，用于name的字符串不能包含任何标点符号，并且不能以数字开头，可以使用单引号代替尖括号
（?:pattern）匹配pattern但是不捕获该匹配到的子表达式，即它是一个非捕获匹配，不存储供以后的匹配，这对于使用or字符| 组合模式
             的部件的情况很有用，例如 industr(?:y|ies)是比industry|industries更经济的表达式
 (?=pattern) 非捕获分组，例如Windows(?=95|98|NT|2000)匹配Windows2000，但是不匹配Windows3.1
（?!pattern）该表达式匹配不处于匹配pattern的字符串的起始点的搜索字符串，它是一个非捕获分组，跟上面的实例正好相反
6.反向引用
1.要匹配两个相同的数字 (\\d)\\1
1.要匹配5个相同的数字 (\\d)\\1{4}
3.匹配个位与千位相同，十位和百位相同 5225  (\\d)(\\d)\\2\\1

